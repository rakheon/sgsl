% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/d2wlasso.R
\name{d2wlasso}
\alias{d2wlasso}
\title{Implement structured variables selection with q-values}
\usage{
d2wlasso(x, z, y, cox.delta = NULL, factor.z = TRUE,
  reg.type = c("linear", "cox")[1], ttest = TRUE,
  q_method = c("bootstrap", "smoother")[2], plots = FALSE,
  pi0.true = FALSE, pi0.val = 0.9, wt = c("one", "t_val", "parcor",
  "p_val", "bhp_val", "adapt", "q_cor", "q_parcor")[7],
  weight_fn = c("identity", "sqrt", "inverse_abs", "square")[1],
  include.z = TRUE, z.wt = 1000, thresh.q = TRUE, alpha = 0.15,
  alpha.bh = 0.05, delta = 2, robust = TRUE, q.old = FALSE,
  lasso.delta.cv.mult = FALSE, vfold = 10, ncv = 100,
  delta.cv.seed = NULL, run.aic.bic = TRUE,
  run.kmeans.aic.bic = TRUE, run.kquart.aic.bic = TRUE,
  run.sort.aic.bic = TRUE, nboot = 100, k = 4,
  direction = "backward")
}
\arguments{
\item{x}{(n by m) matrix of main covariates where m is the number of covariates and n is the sample size}

\item{z}{(n by 1) matrix of additional fixed covariate affecting response variable}

\item{y}{(n by 1) matrix of response variable}

\item{cox.delta}{(n by 1) matrix of status for survival analysis}

\item{factor.z}{logical. If TRUE, the additional fixed variable z is used as factor}

\item{reg.type}{indicates the model for fitting. Either "linear" or "cox". Default is "linear".}

\item{ttest}{logical. If TRUE, p-value for each covariate is computed from the linear regression and this does not require normality of the covariates. If FALSE, p-value is computed as the p-value of the correlation coefficient. Default is FALSE.}

\item{q_method}{indicates the method for choosing optimal tuning parameter in the q-value computation as proposed in Storey and Tibshirani (2003). One of "bootstrap" or "smoother". Default is "smoother" (smoothing spline).}

\item{plots}{logical. If TRUE, figures are plotted. Default is FALSE.}

\item{pi0.true}{logical. If TRUE, the estimate of the true proportion of the null hypothesis is set to the value of pi0.val which is given by the user. If FALSE, the estimate of the true proportion of the null hypothesis is computed by bootstrap or smoothing spline. Default is FALSE.}

\item{pi0.val}{A user supplied estimate of the true proportion of the null hypothesis. Used only when pi0.true is TRUE. Default is 0.9.}

\item{wt}{The weights to be used for the weighted lasso. One of "one","t_val","parcor","p_val","bhp_val","adapt","q_cor" or "q_parcor". "one" gives no weight. "t_val" gives weight of the inverse absolute t-statistics of the regression coefficients. "parcor" gives weight of the inverse absolute partial correlation between the main covariate and the response after accounting for z. "p_val" gives p-value of each predictor's coefficient as weights. "bhp_val" gives Benjamini-Hochberg adjusted p-value of each predictor's coefficient as weights. "adapt" gives adaptive lasso weights, that is, the inverse of the absolute value of regression coefficients. "q_cor" gives weights set to q-values BEFORE taking into account diet. "q_parcor" gives weights set to q-values AFTER taking into account diet.}

\item{weight_fn}{The function applied to the weights for the weighted lasso. One of "identity","sqrt","inverse_abs","square". "identity" is the identity function, "sqrt" is the square root function, "inverse_abs" is the inverse of the absolute value and "square" is the square function. Not used if wt is set to "adapt". Default is "identity".}

\item{include.z}{logical. If TRUE, the additional covariate z is forced to be included in the model. Default is TRUE.}

\item{z.wt}{constant for forcing z in the model. If z is not included in the model even if include.z is TRUE, try different value. Default is 1000.}

\item{thresh.q}{logical. If TRUE, remove excessively small weights by using threshold to maintain stability. The threshold is set to 0.0001.}

\item{alpha}{indicates cut-off for q-values (thresholding). That is, the covariate with q-value less than this cut-off is included in the model.}

\item{alpha.bh}{indicates cut-off for Benjamini-Hochberg adjusted p-value (thresholding). That is, the covariate with BH-adjusted p-value less than this cut-off is included in the model.}

\item{delta}{Among the lasso solution path, the best descriptive model is the one which minimizes the loss function: (residual sum of squares)/(estimator of the model error variance) - (sample size) + delta*(number of predictors in the selected model). If delta = 2, this loss function is Mallows' Cp.}

\item{robust}{indicates whether it is desired to make the estimate more robust for small p-values.}

\item{lasso.delta.cv.mult}{logical. If TRUE, we run vfold cross-validation to select optimal delta multiple times (ncv times). Default is FALSE.}

\item{vfold}{indicates the number of folds of the cross-validation for selecting delta.}

\item{ncv}{indicates the number of cross-validation runs for selecting delta.}

\item{delta.cv.seed}{For reproducible cross-validation result, the seed can be fixed.}

\item{run.aic.bic}{If TRUE, the Cox regression with exclusion frequency-based weights is performed with randomly partitioning the index}

\item{run.kmeans.aic.bic}{If TRUE, the Cox regression with exclusion frequency-based weights is performed with partitioning the index using k-means}

\item{run.kquart.aic.bic}{If TRUE, the Cox regression with exclusion frequency-based weights is performed with partitioning the index using k-quartile}

\item{run.sort.aic.bic}{If TRUE, the Cox regression with exclusion frequency-based weights is performed with partitioning the index using sorted partition}

\item{nboot}{indicates the number of bootstrap samples for the Cox regression with exclusion frequency-based weights}

\item{k}{indicates the number of partitions for the Cox regression with exclusion frequency-based weights. Default is 4.}

\item{direction}{indicates the direction of stepwise regression for the Cox regression with exclusion frequency-based weights. One of "both", "forward" or "backward". Default is "backward".}
}
\value{
\itemize{
   \item \strong{qval:} {q-value as proposed in Storey and Tibshirani (2003)}
   \item \strong{bh.pval:} {Benjamini-Hochberg adjusted p-value as proposed in Benjamini and Hochberg (1995)}
   \item \strong{pval:} {p-value for each covariate}
   \item \strong{out.cor:} {variable selection results for testing if a main covariate has an effect on the response variable, but NOT accounting for the additional fixed covariate z}
   \item \strong{out.parcor:} {variable selection results for testing if a main covariate has an effect on the response variable, but AFTER accounting for the additional fixed covariate z}
   \item \strong{out.benhoch.cor:} {variable selection results from Benjamini-Hochberg adjusted p-values when p-values do not account for the additional fixed covariate z}
   \item \strong{out.benhoch.parcor:} {variable selection results from Benjamini-Hochberg adjusted p-values when p-values account for the additional fixed covariate z}
   \item \strong{out.w:} {variable selection results from weighted lasso}
   \item \strong{alpha:} {level of significance to compare with the q-values}
   \item \strong{alpha.bh:} {level of significance to compare with the Benjamini-Hochberg adjusted p-values}
   \item \strong{delta:} {the multiplier to the number of predictors in the penalized loss function for variable selection. The loss function is defined as: \code{ SSE/(sigma^2) - n + delta*p } where SSE denotes the residual sum of squares, sigma denotes the estimator of the model error variance, n is the sample size and p is the number of predictors in the selected model. }
   \item \strong{cv.delta.w:} {the selected delta from the cross-validation for the weighted lasso with q-values}
   \item \strong{cv.delta.adapt:} {the selected delta from the cross-validation for the adaptive lasso}
   \item \strong{cv.out.w:} {the aggregated result of the cross-validation for the weighted lasso with q-values}
   \item \strong{cv.out.adapt:} {the aggregated result of the cross-validation for the adaptive lasso}
   \item \strong{w.aic.boot:} {variable selection results from AIC and the Cox regression with exclusion frequency-based weights from random partitioning}
   \item \strong{w.bic.boot:} {variable selection results from BIC and the Cox regression with exclusion frequency-based weights from random partitioning}
   \item \strong{w.kmeans.aic.boot:} {variable selection results from AIC and the Cox regression with exclusion frequency-based weights from k-means partitioning}
   \item \strong{w.kmeans.bic.boot:} {variable selection results from BIC and the Cox regression with exclusion frequency-based weights from k-means partitioning}
   \item \strong{w.kquart.aic.boot:} {variable selection results from AIC and the Cox regression with exclusion frequency-based weights from k-quartile partitioning}
   \item \strong{w.kquart.bic.boot:} {variable selection results from BIC and the Cox regression with exclusion frequency-based weights from k-quartile partitioning}
   \item \strong{w.sort.aic.boot:} {variable selection results from AIC and the Cox regression with exclusion frequency-based weights from sorted partitioning}
   \item \strong{w.sort.bic.boot:} {variable selection results from BIC and the Cox regression with exclusion frequency-based weights from sorted partitioning}
}
}
\description{
Implement structured variables selection with q-values
}
\examples{
x = matrix(rnorm(100*5, 0, 1),100,5)
z = matrix(rbinom(100, 1, 0.5),100,1)
y = matrix(z[,1] + 2*x[,1] - 2*x[,2] + rnorm(100, 0, 1), 100)
dwl0 <- d2wlasso(x,z,y)
dwl1 <- d2wlasso(x,z,y,delta=2)
dwl2 <- d2wlasso(x,z,y,include.z=FALSE)
dwl3 <- d2wlasso(x,z,y,weight_fn = "sqrt")
dwl4 <- d2wlasso(x,z,y,wt="adapt")
dwl5 <- d2wlasso(x,z,y,wt="t_val")
dwl6 <- d2wlasso(x,z,y,wt="q_parcor")
dwlcv0 <- d2wlasso(x,z,y,lasso.delta.cv.mult = TRUE, ncv = 3)
dwlcv1 <- d2wlasso(x,z,y,lasso.delta.cv.mult = TRUE, ncv = 3, delta.cv.seed = 1)
dwlcv2 <- d2wlasso(x,z,y,weight_fn = "square",lasso.delta.cv.mult = TRUE, ncv = 3, delta.cv.seed = 1)

x <- matrix(rnorm(100*5, 0, 1),100,5)
z <- matrix(rbinom(100, 1, 0.5),100,1)
y <- matrix(exp(z[,1] + 2*x[,1] - 2*x[,2] + rnorm(100, 0, 2)), 100)
cox.delta <- matrix(1,nrow=length(y),ncol=1)
dwlcox1 <- d2wlasso(x,z,y,cox.delta = cox.delta, reg.type = "cox")
dwlcox2 <- d2wlasso(x,z,y,cox.delta = cox.delta, reg.type = "cox", nboot = 50)
dwlcox3 <- d2wlasso(x,z,y,cox.delta = cox.delta, reg.type = "cox", wt="t_val")
dwlcoxcv1 <- d2wlasso(x,z,y,cox.delta = cox.delta,reg.type = "cox",lasso.delta.cv.mult = TRUE, ncv = 3, nboot = 50)
}
